<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML Sanitizer API Playground</title>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;800&family=Roboto+Slab:wght@100;500&display=swap" rel="stylesheet" crossorigin="anonymous">
  <link href="style.css" rel="stylesheet">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@mikewest">
  <meta name="og:title" content="Play with the HTML Sanitizer API.">
  <meta name="description" content="Learn a little about how `new Sanitizer().sanitize(untrusted_string)` might usefully mitigate injection attacks.">
  <meta name="og:description" content="Learn a little about how `new Sanitizer().sanitize(untrusted_string)` might usefully mitigate injection attacks.">
  <meta name="og:image" content="https://sanitizer-api.dev/card.png">
</head>
<body>
  <h1>HTML Sanitizer API Playground</h1>
  <article>
    <p>
      The <a href="https://wicg.github.io/sanitizer-api/">HTML Sanitizer API</a> is an API that
      sanitizes an untrusted string, minimizing the risk of unintended script execution. Amazing,
      right?
    </p>

    <h2>Input String</h2>
    <textarea id="input">&lt;p&gt;
  This is a very boring string that
  &lt;em onclick="alert('onclick fired!')"&gt;certainly&lt;/em&gt;
  does &lt;span style="font-weight:800;"&gt;not&lt;/span&gt; contain
  injection attacks of any sort.
  &lt;img src="data:image/png," onerror="alert('onerror fired!')"&gt;
&lt;/p&gt;
&lt;style&gt;
&lt;/style&gt;</textarea>
    <p><a href="#" id="permalink">Link to this input.</a></p>

    <h2>Sanitizer Configuration</h2>

    <p>
      The Sanitizer default configuration is safe and will likely suffice for
      many applications. Note that all sanitizers guarantee a safe baseline,
      so even a misconfigured Sanitizer will not allow script execution.
    </p>

    <p>
      <strong>Configuration: </strong>
      <select id="configselect">
        <option value="default">default</option>
        <option value="textonly">text only</option>
        <option value="style">allow simple styling</option>
        <option value="misconfigured">misconfigured to allow event handlers</option>
        <option value="custom">custom (edit below)</option>
      </select>
    </p>

    <p id="setconfig">
      <code>const config = </code>
      <textarea id="configtext"></textarea>
    </p>
    <p>
      <code>const sanitizer = new Sanitizer(<span id="useconfig">config</span>);</code>
    </p>

    <h2>Live Output</h2>

    <p><code>node.replaceChildren(sanitizer.sanitize(<em>input</em>))</code>:</p>
    <div id="output"></div>
    <button id="inject">Inject <em>without</em> sanitization, just for grins.</button>

    <p><code>sanitizer.sanitizeToString(<em>input</em>);</code></p>
    <output for="input"></output>

    <h2>How does it work?</h2>
    <p>
      The API's shape and behavior is still under
      <a href="https://github.com/WICG/sanitizer-api/issues">active discussion</a>, so we'd
      appreciate your early feedback. This page is meant as a quick demonstration of the
      very basics of the API, to give you a feel for it's usage. Here, that boils down to the
      following:
    </p>
    <pre><code>const s = <strong>new Sanitizer()</strong>;
el.replaceChildren(<strong>s.sanitize(<em>untrustedInput</em>)</strong>);</code></pre>
    <p>The goal is for that default configuration to ensure that the browser won't execute any code
    as a result of inserting the resulting nodes. You may need to change the sanitizer's
    configuration if your application has special needs. Configuration options are
    <a href="https://wicg.github.io/sanitizer-api/#config">documented in the specification</a>.
    For example, you may wish to block some style vectors in addition to script:</p>
    <pre><code><strong>const config = {
    dropAttributes: { "style": ["*"] },
    dropElements: [ "style" ]
};</strong>
const s = new Sanitizer(<strong><em>config</em></strong>);
el.replaceChildren(s.sanitize(<em>untrustedInput</em>));</code></pre>

  </article>
  <footer>
    Typos? Mistakes? Poke at <a href="https://github.com/mikewest/sanitizer-playground">mikewest/sanitizer-playground</a> on GitHub.
  </footer>
  <script>
    // Warn if the sanitizer doesn't appear to be available:
    if (!("Sanitizer" in window)) {
      const p = document.createElement('p');
      p.className = "warning";
      p.textContent = "This browser doesn't appear to support the `Sanitizer` interface; nothing below will do much... Try Chrome Canary with `chrome://flags/#enable-experimental-web-platform-features` enabled? Or Firefox Nightly with `dom.security.sanitizer.enabled` set to true?";
      document.querySelector('p').before(p);
    }
    // Exciting constant element references!
    const input = document.querySelector('#input');
    const outputDiv = document.querySelector('#output');
    const outputText = document.querySelector('output');
    const permalink = document.querySelector('#permalink');
    const configSelect = document.querySelector('#configselect');
    const configText = document.querySelector('#configtext');

    const sampleConfigs = {
      default: {},
      textonly: { allowElements: [] },
      style: {
        allowElements: [ "div", "span", "p", "em", "b" ],
        allowAttributes: { "class": ["*"], "style": ["*"] },
      },
      misconfigured: {
        allowElements: [ "em", "img" ],
        allowAttributes: { "onclick": ["*"], "onerror": ["*"] },
      },
    };

    // Populate <textarea> via an `input` GET parameter:
    const params = new URLSearchParams(window.location.search);
    if (params.has("input")) {
      input.value = decodeURIComponent(params.get('input'));
    }

    // Register the pure injection Handler
    document.querySelector('#inject').addEventListener('click', _ => {
      outputDiv.innerHTML = input.value;
    });

    // Register updater for <textarea> input and <select> changes:
    function update() {
      // Update the permalink:
      permalink.href = "?input=" + encodeURIComponent(input.value);

      // Determine the current config and update the text box.
      const currentConfig = configSelect.selectedOptions[0].value;
      if (currentConfig in sampleConfigs)
        configText.value = JSON.stringify(sampleConfigs[currentConfig], null, 1);

      // Hide/show the config box for default/non-default configs.
      const isDefault = currentConfig == "default" ? "none" : "";
      document.querySelector("#setconfig").style.display = isDefault;
      document.querySelector("#useconfig").style.display = isDefault;

      // Make the config box editable when "custom" is selected.
      configText.readOnly = currentConfig != "custom";

      // Create a Sanitizer with that configuration:
      try {
        const conf = JSON.parse(configText.value);
        const sanitizer = new Sanitizer(conf);

        // Use the sanitizer to inject the <textarea>'s value safely into the DOM
        // via `Node.replaceChildren()` and to render the textual output into the
        // <output> element's `Node.innerText`:
        outputDiv.replaceChildren(sanitizer.sanitize(input.value));
        outputText.textContent = sanitizer.sanitizeToString(input.value);
      } catch (err) {
        // Display an error when we can't parse the config text.
        const p = document.createElement('p');
        p.className = "warning";
        p.textContent = "Cannot parse the configuration dictionary.";
        outputDiv.replaceChildren(p);
        outputText.textContent = "";
      }
    }
    input.addEventListener('keyup', update);
    configSelect.addEventListener('change', update);
    configText.addEventListener('input', update);

    // Update the output with whatever's in the <textarea> to begin with.
    update();
  </script>
</body>
</html>
